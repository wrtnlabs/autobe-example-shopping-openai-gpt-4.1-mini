import jwt from "jsonwebtoken";
import { MyGlobal } from "../MyGlobal";
import typia, { tags } from "typia";
import { Prisma } from "@prisma/client";
import { v4 } from "uuid";
import { toISOStringSafe } from "../util/toISOStringSafe";
import { IShoppingMallFraudDetection } from "@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMallFraudDetection";
import { IPageIShoppingMallFraudDetection } from "@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingMallFraudDetection";
import { AdminuserPayload } from "../decorators/payload/AdminuserPayload";

/**
 * Search and retrieve a filtered, paginated list of fraud detections
 *
 * Retrieves a filtered, pageable, and searchable list of fraud detection
 * records generated by AI systems in the shopping mall backend. The retrieved
 * data includes references to the member user flagged for potential fraud,
 * detected order if applicable, fraud detection classification, confidence
 * scores assigned by AI models, current resolution status of the fraud case,
 * and relevant timestamps.
 *
 * Access is restricted to authorized admin users. The response provides a
 * paginated summary view optimized for fraud analysis and triage.
 *
 * @param props - Object containing the authenticated admin user and search
 *   request body
 * @param props.adminUser - The authenticated admin user payload
 * @param props.body - The request body containing search criteria, filters, and
 *   pagination
 * @returns A paginated list of fraud detection summaries matching the search
 *   criteria
 * @throws {Error} Throws if any unexpected error occurs during database query
 */
export async function patch__shoppingMall_adminUser_fraudDetections(props: {
  adminUser: AdminuserPayload;
  body: IShoppingMallFraudDetection.IRequest;
}): Promise<IPageIShoppingMallFraudDetection.ISummary> {
  const { adminUser, body } = props;
  const page = body.page ?? 0;
  const limit = body.limit ?? 10;

  const whereConditions = { deleted_at: null } as {
    deleted_at: null;
    user_id?: string & tags.Format<"uuid">;
    order_id?: string & tags.Format<"uuid">;
    detection_type?: string;
    resolution_status?: string;
    detected_at?: {
      gte?: string & tags.Format<"date-time">;
      lte?: string & tags.Format<"date-time">;
    };
  };

  if (body.user_id !== undefined && body.user_id !== null) {
    whereConditions.user_id = body.user_id;
  }
  if (body.order_id !== undefined && body.order_id !== null) {
    whereConditions.order_id = body.order_id;
  }
  if (body.detection_type !== undefined && body.detection_type !== null) {
    whereConditions.detection_type = body.detection_type;
  }
  if (body.resolution_status !== undefined && body.resolution_status !== null) {
    whereConditions.resolution_status = body.resolution_status;
  }
  if (
    (body.detected_start !== undefined && body.detected_start !== null) ||
    (body.detected_end !== undefined && body.detected_end !== null)
  ) {
    whereConditions.detected_at = {};
    if (body.detected_start !== undefined && body.detected_start !== null) {
      whereConditions.detected_at.gte = body.detected_start;
    }
    if (body.detected_end !== undefined && body.detected_end !== null) {
      whereConditions.detected_at.lte = body.detected_end;
    }
  }

  const [results, total] = await Promise.all([
    MyGlobal.prisma.shopping_mall_fraud_detections.findMany({
      where: whereConditions,
      orderBy: { detected_at: "desc" },
      skip: page * limit,
      take: limit,
    }),
    MyGlobal.prisma.shopping_mall_fraud_detections.count({
      where: whereConditions,
    }),
  ]);

  return {
    pagination: {
      current: Number(page),
      limit: Number(limit),
      records: total,
      pages: Math.ceil(total / Number(limit)),
    },
    data: results.map((item) => ({
      id: item.id,
      user_id: item.user_id,
      detection_type: item.detection_type,
      confidence_score: item.confidence_score,
      resolution_status: item.resolution_status,
      detected_at: toISOStringSafe(item.detected_at),
    })),
  };
}
