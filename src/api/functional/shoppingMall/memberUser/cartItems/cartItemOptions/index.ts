import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCartItemOption } from "../../../../../structures/IShoppingMallCartItemOption";
import { IPageIShoppingMallCartItemOption } from "../../../../../structures/IPageIShoppingMallCartItemOption";

/**
 * Add a new option selection to a cart item. Request must specify option group
 * and sale option references.
 *
 * Users may customize cart items by selecting applicable options.
 *
 * Server validates option group and option existence.
 *
 * Errors include 400 Bad Request for invalid data and 404 if the cart item does
 * not exist.
 *
 * Operates on shopping_mall_cart_item_options entity.
 *
 * @param props.connection
 * @param props.cartItemId Unique identifier of the target cart item
 * @param props.body Cart item option creation data
 * @path /shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions
 * @accessor api.functional.shoppingMall.memberUser.cartItems.cartItemOptions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target cart item */
    cartItemId: string & tags.Format<"uuid">;

    /** Cart item option creation data */
    body: IShoppingMallCartItemOption.ICreate;
  };
  export type Body = IShoppingMallCartItemOption.ICreate;
  export type Response = IShoppingMallCartItemOption;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/memberUser/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}/cartItemOptions`;
  export const random = (): IShoppingMallCartItemOption =>
    typia.random<IShoppingMallCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List option selections for a specific cart item.
 *
 * Retrieve detailed option selections of a cart item specified by cartItemId.
 *
 * Supports filtering, searching, and pagination.
 *
 * Ensures users can manage and view option data associated with their cart
 * items.
 *
 * Errors include 404 if the cart item does not exist.
 *
 * Relates to shopping_mall_cart_item_options table and connected entities. This
 * operation requires authorization roles memberUser and adminUser.
 *
 * @param props.connection
 * @param props.cartItemId Unique identifier of the target cart item
 * @param props.body Search criteria and pagination for cart item options
 * @path /shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions
 * @accessor api.functional.shoppingMall.memberUser.cartItems.cartItemOptions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target cart item */
    cartItemId: string & tags.Format<"uuid">;

    /** Search criteria and pagination for cart item options */
    body: IShoppingMallCartItemOption.IRequest;
  };
  export type Body = IShoppingMallCartItemOption.IRequest;
  export type Response = IPageIShoppingMallCartItemOption;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/memberUser/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}/cartItemOptions`;
  export const random = (): IPageIShoppingMallCartItemOption =>
    typia.random<IPageIShoppingMallCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get specific cart item option info by ID.
 *
 * Get detailed information for a specific cart item option by ID under the cart
 * item identified by cartItemId.
 *
 * Accessible to authenticated users managing their carts or administrators.
 *
 * Errors include 404 if the cart item or option does not exist.
 *
 * Operates on shopping_mall_cart_item_options entity.
 *
 * @param props.connection
 * @param props.cartItemId Unique identifier of the target cart item
 * @param props.cartItemOptionId Unique identifier of the cart item option
 * @path /shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId
 * @accessor api.functional.shoppingMall.memberUser.cartItems.cartItemOptions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target cart item */
    cartItemId: string & tags.Format<"uuid">;

    /** Unique identifier of the cart item option */
    cartItemOptionId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCartItemOption;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/memberUser/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}/cartItemOptions/${encodeURIComponent(props.cartItemOptionId ?? "null")}`;
  export const random = (): IShoppingMallCartItemOption =>
    typia.random<IShoppingMallCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.param("cartItemOptionId")(() =>
        typia.assert(props.cartItemOptionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific cart item option by ID.
 *
 * Update the details of a cart item option identified by cartItemId and
 * cartItemOptionId. Cart item options represent selected product option groups
 * and sale options for items in a shopping cart. This update allows
 * modification of option group and option selections.
 *
 * This operation assures data consistency by enforcing valid UUID references
 * and proper linking to the shopping cart item and product option entities.
 *
 * Authorized roles include guestUser, memberUser, sellerUser, and adminUser
 * indicating authenticated access with varying permissions.
 *
 * @param props.connection
 * @param props.cartItemId Unique identifier of the cart item
 * @param props.cartItemOptionId Unique identifier of the cart item option
 * @param props.body Data needed to update a cart item option
 * @path /shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId
 * @accessor api.functional.shoppingMall.memberUser.cartItems.cartItemOptions.updateCartItemOption
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateCartItemOption(
  connection: IConnection,
  props: updateCartItemOption.Props,
): Promise<updateCartItemOption.Response> {
  return true === connection.simulate
    ? updateCartItemOption.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateCartItemOption.METADATA,
          path: updateCartItemOption.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateCartItemOption {
  export type Props = {
    /** Unique identifier of the cart item */
    cartItemId: string & tags.Format<"uuid">;

    /** Unique identifier of the cart item option */
    cartItemOptionId: string & tags.Format<"uuid">;

    /** Data needed to update a cart item option */
    body: IShoppingMallCartItemOption.IUpdate;
  };
  export type Body = IShoppingMallCartItemOption.IUpdate;
  export type Response = IShoppingMallCartItemOption;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/memberUser/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}/cartItemOptions/${encodeURIComponent(props.cartItemOptionId ?? "null")}`;
  export const random = (): IShoppingMallCartItemOption =>
    typia.random<IShoppingMallCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: updateCartItemOption.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateCartItemOption.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.param("cartItemOptionId")(() =>
        typia.assert(props.cartItemOptionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a specific cart item option.
 *
 * Soft delete the cart item option specified by cartItemId and
 * cartItemOptionId. This action marks the record as deleted without physically
 * removing it from the database, enabling audit and recovery.
 *
 * This operation requires authorization as guestUser, memberUser, sellerUser,
 * or adminUser, reflecting system access control policies.
 *
 * No response body is returned on success. Invalid IDs or unauthorized attempts
 * result in errors.
 *
 * @param props.connection
 * @param props.cartItemId Unique identifier of the cart item
 * @param props.cartItemOptionId Unique identifier of the cart item option
 * @path /shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId
 * @accessor api.functional.shoppingMall.memberUser.cartItems.cartItemOptions.eraseCartItemOption
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseCartItemOption(
  connection: IConnection,
  props: eraseCartItemOption.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseCartItemOption.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseCartItemOption.METADATA,
          path: eraseCartItemOption.path(props),
          status: null,
        },
      );
}
export namespace eraseCartItemOption {
  export type Props = {
    /** Unique identifier of the cart item */
    cartItemId: string & tags.Format<"uuid">;

    /** Unique identifier of the cart item option */
    cartItemOptionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/memberUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/memberUser/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}/cartItemOptions/${encodeURIComponent(props.cartItemOptionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseCartItemOption.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseCartItemOption.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.param("cartItemOptionId")(() =>
        typia.assert(props.cartItemOptionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
