import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallDepositCharge } from "../../../../structures/IShoppingMallDepositCharge";
import { IPageIShoppingMallDepositCharge } from "../../../../structures/IPageIShoppingMallDepositCharge";

/**
 * Create a new deposit charge application with required payment and user
 * details.
 *
 * The system records the charge request, initial status, and association with
 * the user.
 *
 * The operation returns the created deposit charge record for confirmation and
 * further processing.
 *
 * This creation aligns with the shopping_mall_deposit_charges schema, ensuring
 * all data consistency rules are followed.
 *
 * @param props.connection
 * @param props.body Creation information of the deposit charge application
 * @path /shoppingMall/memberUser/depositCharges
 * @accessor api.functional.shoppingMall.memberUser.depositCharges.createDepositCharge
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createDepositCharge(
  connection: IConnection,
  props: createDepositCharge.Props,
): Promise<createDepositCharge.Response> {
  return true === connection.simulate
    ? createDepositCharge.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createDepositCharge.METADATA,
          path: createDepositCharge.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createDepositCharge {
  export type Props = {
    /** Creation information of the deposit charge application */
    body: IShoppingMallDepositCharge.ICreate;
  };
  export type Body = IShoppingMallDepositCharge.ICreate;
  export type Response = IShoppingMallDepositCharge;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/memberUser/depositCharges",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/memberUser/depositCharges";
  export const random = (): IShoppingMallDepositCharge =>
    typia.random<IShoppingMallDepositCharge>();
  export const simulate = (
    connection: IConnection,
    props: createDepositCharge.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createDepositCharge.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search deposit charge applications.
 *
 * Search and retrieve a list of deposit charge application records filtered by
 * various criteria including status, payment provider, user, and date range.
 *
 * This operation supports pagination, sorting, and filtering to manage large
 * data sets effectively.
 *
 * It operates on the shopping_mall_deposit_charges table which records deposit
 * charging requests and their processing status.
 *
 * Authorized users can filter results to view their own or managed charge
 * applications.
 *
 * The result set includes payment details and status information relevant for
 * operational workflows and user queries.
 *
 * @param props.connection
 * @param props.body Filtering and pagination criteria for deposit charges
 * @path /shoppingMall/memberUser/depositCharges
 * @accessor api.functional.shoppingMall.memberUser.depositCharges.searchDepositCharges
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function searchDepositCharges(
  connection: IConnection,
  props: searchDepositCharges.Props,
): Promise<searchDepositCharges.Response> {
  return true === connection.simulate
    ? searchDepositCharges.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...searchDepositCharges.METADATA,
          path: searchDepositCharges.path(),
          status: null,
        },
        props.body,
      );
}
export namespace searchDepositCharges {
  export type Props = {
    /** Filtering and pagination criteria for deposit charges */
    body: IShoppingMallDepositCharge.IRequest;
  };
  export type Body = IShoppingMallDepositCharge.IRequest;
  export type Response = IPageIShoppingMallDepositCharge;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/memberUser/depositCharges",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/memberUser/depositCharges";
  export const random = (): IPageIShoppingMallDepositCharge =>
    typia.random<IPageIShoppingMallDepositCharge>();
  export const simulate = (
    connection: IConnection,
    props: searchDepositCharges.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: searchDepositCharges.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve deposit charge application details.
 *
 * Retrieve detailed deposit charge information by depositChargeId. The deposit
 * charge record includes payment amount, status, provider, and timestamps.
 *
 * Access is restricted to authorized users with rights to view the specified
 * deposit charge.
 *
 * The operation returns a single deposit charge entity from the
 * shopping_mall_deposit_charges table.
 *
 * @param props.connection
 * @param props.depositChargeId Target deposit charge's unique identifier
 * @path /shoppingMall/memberUser/depositCharges/:depositChargeId
 * @accessor api.functional.shoppingMall.memberUser.depositCharges.atDepositCharge
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atDepositCharge(
  connection: IConnection,
  props: atDepositCharge.Props,
): Promise<atDepositCharge.Response> {
  return true === connection.simulate
    ? atDepositCharge.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atDepositCharge.METADATA,
          path: atDepositCharge.path(props),
          status: null,
        },
      );
}
export namespace atDepositCharge {
  export type Props = {
    /** Target deposit charge's unique identifier */
    depositChargeId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallDepositCharge;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/memberUser/depositCharges/:depositChargeId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/memberUser/depositCharges/${encodeURIComponent(props.depositChargeId ?? "null")}`;
  export const random = (): IShoppingMallDepositCharge =>
    typia.random<IShoppingMallDepositCharge>();
  export const simulate = (
    connection: IConnection,
    props: atDepositCharge.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atDepositCharge.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("depositChargeId")(() =>
        typia.assert(props.depositChargeId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing deposit charge application with new information.
 *
 * Allows modification of payment status, amounts, provider details, and charge
 * status.
 *
 * Ensures proper validation and authorization for updating deposit charge
 * records.
 *
 * The operation returns the updated entity reflecting the latest state.
 *
 * @param props.connection
 * @param props.depositChargeId Target deposit charge's unique identifier
 * @param props.body Updated deposit charge information
 * @path /shoppingMall/memberUser/depositCharges/:depositChargeId
 * @accessor api.functional.shoppingMall.memberUser.depositCharges.updateDepositCharge
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateDepositCharge(
  connection: IConnection,
  props: updateDepositCharge.Props,
): Promise<updateDepositCharge.Response> {
  return true === connection.simulate
    ? updateDepositCharge.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateDepositCharge.METADATA,
          path: updateDepositCharge.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateDepositCharge {
  export type Props = {
    /** Target deposit charge's unique identifier */
    depositChargeId: string & tags.Format<"uuid">;

    /** Updated deposit charge information */
    body: IShoppingMallDepositCharge.IUpdate;
  };
  export type Body = IShoppingMallDepositCharge.IUpdate;
  export type Response = IShoppingMallDepositCharge;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/memberUser/depositCharges/:depositChargeId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/memberUser/depositCharges/${encodeURIComponent(props.depositChargeId ?? "null")}`;
  export const random = (): IShoppingMallDepositCharge =>
    typia.random<IShoppingMallDepositCharge>();
  export const simulate = (
    connection: IConnection,
    props: updateDepositCharge.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateDepositCharge.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("depositChargeId")(() =>
        typia.assert(props.depositChargeId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an existing deposit charge application permanently from the database.
 *
 * This is a hard deletion with no recovery. The depositChargeId path parameter
 * identifies the target to delete.
 *
 * Operation is restricted to authorized users.
 *
 * @param props.connection
 * @param props.depositChargeId Target deposit charge's unique identifier
 * @path /shoppingMall/memberUser/depositCharges/:depositChargeId
 * @accessor api.functional.shoppingMall.memberUser.depositCharges.eraseDepositCharge
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseDepositCharge(
  connection: IConnection,
  props: eraseDepositCharge.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseDepositCharge.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseDepositCharge.METADATA,
          path: eraseDepositCharge.path(props),
          status: null,
        },
      );
}
export namespace eraseDepositCharge {
  export type Props = {
    /** Target deposit charge's unique identifier */
    depositChargeId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/memberUser/depositCharges/:depositChargeId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/memberUser/depositCharges/${encodeURIComponent(props.depositChargeId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseDepositCharge.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseDepositCharge.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("depositChargeId")(() =>
        typia.assert(props.depositChargeId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
