import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCartItemOption } from "../../../../../structures/IShoppingMallCartItemOption";

/**
 * Update a specific cart item option by ID.
 *
 * Update the details of a cart item option identified by cartItemId and
 * cartItemOptionId. Cart item options represent selected product option groups
 * and sale options for items in a shopping cart. This update allows
 * modification of option group and option selections.
 *
 * This operation assures data consistency by enforcing valid UUID references
 * and proper linking to the shopping cart item and product option entities.
 *
 * Authorized roles include guestUser, memberUser, sellerUser, and adminUser
 * indicating authenticated access with varying permissions.
 *
 * @param props.connection
 * @param props.cartItemId Unique identifier of the cart item
 * @param props.cartItemOptionId Unique identifier of the cart item option
 * @param props.body Data needed to update a cart item option
 * @path /shoppingMall/guestUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId
 * @accessor api.functional.shoppingMall.guestUser.cartItems.cartItemOptions.updateCartItemOption
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateCartItemOption(
  connection: IConnection,
  props: updateCartItemOption.Props,
): Promise<updateCartItemOption.Response> {
  return true === connection.simulate
    ? updateCartItemOption.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateCartItemOption.METADATA,
          path: updateCartItemOption.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateCartItemOption {
  export type Props = {
    /** Unique identifier of the cart item */
    cartItemId: string & tags.Format<"uuid">;

    /** Unique identifier of the cart item option */
    cartItemOptionId: string & tags.Format<"uuid">;

    /** Data needed to update a cart item option */
    body: IShoppingMallCartItemOption.IUpdate;
  };
  export type Body = IShoppingMallCartItemOption.IUpdate;
  export type Response = IShoppingMallCartItemOption;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/guestUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/guestUser/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}/cartItemOptions/${encodeURIComponent(props.cartItemOptionId ?? "null")}`;
  export const random = (): IShoppingMallCartItemOption =>
    typia.random<IShoppingMallCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: updateCartItemOption.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateCartItemOption.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.param("cartItemOptionId")(() =>
        typia.assert(props.cartItemOptionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a specific cart item option.
 *
 * Soft delete the cart item option specified by cartItemId and
 * cartItemOptionId. This action marks the record as deleted without physically
 * removing it from the database, enabling audit and recovery.
 *
 * This operation requires authorization as guestUser, memberUser, sellerUser,
 * or adminUser, reflecting system access control policies.
 *
 * No response body is returned on success. Invalid IDs or unauthorized attempts
 * result in errors.
 *
 * @param props.connection
 * @param props.cartItemId Unique identifier of the cart item
 * @param props.cartItemOptionId Unique identifier of the cart item option
 * @path /shoppingMall/guestUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId
 * @accessor api.functional.shoppingMall.guestUser.cartItems.cartItemOptions.eraseCartItemOption
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseCartItemOption(
  connection: IConnection,
  props: eraseCartItemOption.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseCartItemOption.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseCartItemOption.METADATA,
          path: eraseCartItemOption.path(props),
          status: null,
        },
      );
}
export namespace eraseCartItemOption {
  export type Props = {
    /** Unique identifier of the cart item */
    cartItemId: string & tags.Format<"uuid">;

    /** Unique identifier of the cart item option */
    cartItemOptionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/guestUser/cartItems/:cartItemId/cartItemOptions/:cartItemOptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/guestUser/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}/cartItemOptions/${encodeURIComponent(props.cartItemOptionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseCartItemOption.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseCartItemOption.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.param("cartItemOptionId")(() =>
        typia.assert(props.cartItemOptionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
