import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrder } from "../../../../structures/IShoppingMallOrder";
export * as items from "./items/index";
export * as payments from "./payments/index";

/**
 * Get detailed information for a specific order.
 *
 * Retrieve detailed information of an order by its unique identifier orderId.
 * The response includes comprehensive data such as order status, payment
 * status, total price, and associated member, channel, and section
 * information.
 *
 * This operation requires user authentication and authorization with roles
 * guestUser, memberUser, sellerUser, or adminUser.
 *
 * Unauthorized access or invalid order IDs result in error responses.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order
 * @path /shoppingMall/guestUser/orders/:orderId
 * @accessor api.functional.shoppingMall.guestUser.orders.atOrder
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atOrder(
  connection: IConnection,
  props: atOrder.Props,
): Promise<atOrder.Response> {
  return true === connection.simulate
    ? atOrder.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atOrder.METADATA,
          path: atOrder.path(props),
          status: null,
        },
      );
}
export namespace atOrder {
  export type Props = {
    /** Unique identifier of the order */
    orderId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/guestUser/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/guestUser/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: atOrder.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atOrder.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing order's details.
 *
 * Updates the details of an existing order identified by orderId with the data
 * supplied.
 *
 * Authorization is required as guestUser, memberUser, sellerUser, or adminUser.
 *
 * Successful updates return the latest order data.
 *
 * Errors occur if the order is not found or update conflicts with business
 * rules.
 *
 * This endpoint supports order lifecycle management and payment confirmation
 * updates.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to update
 * @param props.body Order update payload
 * @path /shoppingMall/guestUser/orders/:orderId
 * @accessor api.functional.shoppingMall.guestUser.orders.updateOrder
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateOrder(
  connection: IConnection,
  props: updateOrder.Props,
): Promise<updateOrder.Response> {
  return true === connection.simulate
    ? updateOrder.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateOrder.METADATA,
          path: updateOrder.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateOrder {
  export type Props = {
    /** Unique identifier of the order to update */
    orderId: string & tags.Format<"uuid">;

    /** Order update payload */
    body: IShoppingMallOrder.IUpdate;
  };
  export type Body = IShoppingMallOrder.IUpdate;
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/guestUser/orders/:orderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/guestUser/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: updateOrder.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateOrder.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete an order by ID.
 *
 * Soft delete an order specified by orderId, marking it as deleted without
 * physical removal.
 *
 * Authorized roles include guestUser, memberUser, sellerUser, and adminUser.
 *
 * Returns no content on success.
 *
 * Errors if the order does not exist or unauthorized.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to delete
 * @path /shoppingMall/guestUser/orders/:orderId
 * @accessor api.functional.shoppingMall.guestUser.orders.eraseOrder
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseOrder(
  connection: IConnection,
  props: eraseOrder.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseOrder.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseOrder.METADATA,
          path: eraseOrder.path(props),
          status: null,
        },
      );
}
export namespace eraseOrder {
  export type Props = {
    /** Unique identifier of the order to delete */
    orderId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/guestUser/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/guestUser/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseOrder.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseOrder.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new order.
 *
 * Creates a new order application record in the system using the provided data
 * in the request body.
 *
 * The operation requires appropriate authorization among guestUser, memberUser,
 * sellerUser, or adminUser.
 *
 * On success, the created order information is returned for confirmation and
 * subsequent processing.
 *
 * Validation errors are returned in case of missing or incorrect data.
 *
 * This endpoint drives the crucial step of order placement and initiates
 * downstream operations like payment processing.
 *
 * @param props.connection
 * @param props.body Order creation payload
 * @path /shoppingMall/guestUser/orders
 * @accessor api.functional.shoppingMall.guestUser.orders.createOrder
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createOrder(
  connection: IConnection,
  props: createOrder.Props,
): Promise<createOrder.Response> {
  return true === connection.simulate
    ? createOrder.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createOrder.METADATA,
          path: createOrder.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createOrder {
  export type Props = {
    /** Order creation payload */
    body: IShoppingMallOrder.ICreate;
  };
  export type Body = IShoppingMallOrder.ICreate;
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/guestUser/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/guestUser/orders";
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: createOrder.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createOrder.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
