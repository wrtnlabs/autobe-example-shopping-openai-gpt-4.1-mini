import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCategoryRelations } from "../../../../../../structures/IShoppingMallCategoryRelations";
import { IPageIShoppingMallCategoryRelations } from "../../../../../../structures/IPageIShoppingMallCategoryRelations";

/**
 * Create a child category relation under a specific parent category.
 *
 * This API operation allows authorized users to create a new child relationship
 * under the specified parent category. The parent category is identified by its
 * unique ID provided in the URL path. By adding a child relation,
 * administrators can build hierarchical category trees necessary for organizing
 * products effectively within the shopping mall channels.
 *
 * Security considerations include restricting access to administrative users
 * who have permission to manage category structures. Validation rules require
 * that the child category ID provided in the request body corresponds to an
 * existing category and that the new relation does not duplicate existing
 * ones.
 *
 * The Prisma schema defines the 'shopping_mall_category_relations' table where
 * each record represents a parent-child linkage between categories, with soft
 * delete support via the 'deleted_at' timestamp.
 *
 * On successful creation, the API returns the newly created relation with all
 * relevant fields. Errors will be returned if the parent category ID in the
 * path or child category ID in the body are invalid or if relation constraints
 * are violated.
 *
 * @param props.connection
 * @param props.categoryId Unique identifier of the parent category
 * @param props.body Information for creating a new child category relation
 * @path /shoppingMall/adminUser/categories/:categoryId/categoryRelations/child
 * @accessor api.functional.shoppingMall.adminUser.categories.categoryRelations.child.createChildCategoryRelation
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createChildCategoryRelation(
  connection: IConnection,
  props: createChildCategoryRelation.Props,
): Promise<createChildCategoryRelation.Response> {
  return true === connection.simulate
    ? createChildCategoryRelation.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createChildCategoryRelation.METADATA,
          path: createChildCategoryRelation.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createChildCategoryRelation {
  export type Props = {
    /** Unique identifier of the parent category */
    categoryId: string & tags.Format<"uuid">;

    /** Information for creating a new child category relation */
    body: IShoppingMallCategoryRelations.ICreate;
  };
  export type Body = IShoppingMallCategoryRelations.ICreate;
  export type Response = IShoppingMallCategoryRelations;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/adminUser/categories/:categoryId/categoryRelations/child",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/adminUser/categories/${encodeURIComponent(props.categoryId ?? "null")}/categoryRelations/child`;
  export const random = (): IShoppingMallCategoryRelations =>
    typia.random<IShoppingMallCategoryRelations>();
  export const simulate = (
    connection: IConnection,
    props: createChildCategoryRelation.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createChildCategoryRelation.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List child category relations for a parent category with filters and
 * pagination.
 *
 * Retrieve a filtered and paginated list of child category relations for a
 * specified parent category.
 *
 * Filters, sorts, and pagination parameters can be included to efficiently
 * navigate the hierarchical structure.
 *
 * Operation affects the shopping_mall_category_relations table with a focus on
 * child relations where the parent ID is the categoryId.
 *
 * Only accessible to admin users.
 *
 * Returns summarized data of each child relation.
 *
 * Error handling includes invalid category ID and authorization failures.
 *
 * @param props.connection
 * @param props.categoryId Unique identifier of the parent category
 * @param props.body Filter, sort, and pagination parameters for child category
 *   relations
 * @path /shoppingMall/adminUser/categories/:categoryId/categoryRelations/child
 * @accessor api.functional.shoppingMall.adminUser.categories.categoryRelations.child.indexChild
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexChild(
  connection: IConnection,
  props: indexChild.Props,
): Promise<indexChild.Response> {
  return true === connection.simulate
    ? indexChild.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexChild.METADATA,
          path: indexChild.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace indexChild {
  export type Props = {
    /** Unique identifier of the parent category */
    categoryId: string & tags.Format<"uuid">;

    /** Filter, sort, and pagination parameters for child category relations */
    body: IShoppingMallCategoryRelations.IRequest;
  };
  export type Body = IShoppingMallCategoryRelations.IRequest;
  export type Response = IPageIShoppingMallCategoryRelations.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/adminUser/categories/:categoryId/categoryRelations/child",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/adminUser/categories/${encodeURIComponent(props.categoryId ?? "null")}/categoryRelations/child`;
  export const random = (): IPageIShoppingMallCategoryRelations.ISummary =>
    typia.random<IPageIShoppingMallCategoryRelations.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexChild.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexChild.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get specific child category relation detail by relation ID.
 *
 * Get detailed information about a specific child category relation by
 * relationId where the category identified by categoryId is the parent.
 *
 * Only admin users can access this endpoint.
 *
 * Returns the full relation object.
 *
 * Errors if relation ID does not exist or user is unauthorized.
 *
 * @param props.connection
 * @param props.categoryId Unique identifier of the parent category
 * @param props.relationId Unique identifier of the child category relation
 * @path /shoppingMall/adminUser/categories/:categoryId/categoryRelations/child/:relationId
 * @accessor api.functional.shoppingMall.adminUser.categories.categoryRelations.child.atChild
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atChild(
  connection: IConnection,
  props: atChild.Props,
): Promise<atChild.Response> {
  return true === connection.simulate
    ? atChild.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atChild.METADATA,
          path: atChild.path(props),
          status: null,
        },
      );
}
export namespace atChild {
  export type Props = {
    /** Unique identifier of the parent category */
    categoryId: string & tags.Format<"uuid">;

    /** Unique identifier of the child category relation */
    relationId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCategoryRelations;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/adminUser/categories/:categoryId/categoryRelations/child/:relationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/adminUser/categories/${encodeURIComponent(props.categoryId ?? "null")}/categoryRelations/child/${encodeURIComponent(props.relationId ?? "null")}`;
  export const random = (): IShoppingMallCategoryRelations =>
    typia.random<IShoppingMallCategoryRelations>();
  export const simulate = (
    connection: IConnection,
    props: atChild.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atChild.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.param("relationId")(() => typia.assert(props.relationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a child category relation under a specific parent category.
 *
 * This API operation permits authorized administrative users to update the
 * child category linkage of an existing parent-child category relation. The
 * relation to update is identified by its unique 'relationId' and the parent
 * category by 'categoryId' passed in the URL path.
 *
 * The request body must specify the new child category ID to set for this
 * relation. Access is restricted to users with proper administrative
 * privileges.
 *
 * The underlying database entity is the 'shopping_mall_category_relations'
 * table, which tracks parent-child category relationships with a soft delete
 * mechanism. The update must ensure that the new child category exists and that
 * the updated relation does not violate uniqueness constraints.
 *
 * Upon success, the updated relation record is returned. Error cases include
 * invalid IDs or violations of relational constraints.
 *
 * @param props.connection
 * @param props.categoryId Unique identifier of the parent category
 * @param props.relationId Unique identifier of the child category relation
 * @param props.body Updates to apply to the child category relation
 * @path /shoppingMall/adminUser/categories/:categoryId/categoryRelations/child/:relationId
 * @accessor api.functional.shoppingMall.adminUser.categories.categoryRelations.child.updateChildCategoryRelation
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateChildCategoryRelation(
  connection: IConnection,
  props: updateChildCategoryRelation.Props,
): Promise<updateChildCategoryRelation.Response> {
  return true === connection.simulate
    ? updateChildCategoryRelation.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateChildCategoryRelation.METADATA,
          path: updateChildCategoryRelation.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateChildCategoryRelation {
  export type Props = {
    /** Unique identifier of the parent category */
    categoryId: string & tags.Format<"uuid">;

    /** Unique identifier of the child category relation */
    relationId: string & tags.Format<"uuid">;

    /** Updates to apply to the child category relation */
    body: IShoppingMallCategoryRelations.IUpdate;
  };
  export type Body = IShoppingMallCategoryRelations.IUpdate;
  export type Response = IShoppingMallCategoryRelations;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/adminUser/categories/:categoryId/categoryRelations/child/:relationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/adminUser/categories/${encodeURIComponent(props.categoryId ?? "null")}/categoryRelations/child/${encodeURIComponent(props.relationId ?? "null")}`;
  export const random = (): IShoppingMallCategoryRelations =>
    typia.random<IShoppingMallCategoryRelations>();
  export const simulate = (
    connection: IConnection,
    props: updateChildCategoryRelation.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateChildCategoryRelation.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.param("relationId")(() => typia.assert(props.relationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a child category relation under a specific parent category.
 *
 * This API operation allows authorized administrators to delete an existing
 * child category relation from a parent category. The parent category and the
 * relation are identified via 'categoryId' and 'relationId' path parameters
 * respectively.
 *
 * Deleting this relation impacts the category hierarchy and product
 * organization, so proper authorization and validation are required.
 *
 * The underlying table is 'shopping_mall_category_relations' which records
 * parent-child relations among categories. The operation permanently removes
 * the record, ensuring no residual links remain.
 *
 * Error handling includes checks against invalid or non-existent IDs and
 * ensuring referential integrity is maintained system-wide.
 *
 * @param props.connection
 * @param props.categoryId Unique identifier of the parent category
 * @param props.relationId Unique identifier of the child category relation
 * @path /shoppingMall/adminUser/categories/:categoryId/categoryRelations/child/:relationId
 * @accessor api.functional.shoppingMall.adminUser.categories.categoryRelations.child.eraseChildCategoryRelation
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseChildCategoryRelation(
  connection: IConnection,
  props: eraseChildCategoryRelation.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseChildCategoryRelation.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseChildCategoryRelation.METADATA,
          path: eraseChildCategoryRelation.path(props),
          status: null,
        },
      );
}
export namespace eraseChildCategoryRelation {
  export type Props = {
    /** Unique identifier of the parent category */
    categoryId: string & tags.Format<"uuid">;

    /** Unique identifier of the child category relation */
    relationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/adminUser/categories/:categoryId/categoryRelations/child/:relationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/adminUser/categories/${encodeURIComponent(props.categoryId ?? "null")}/categoryRelations/child/${encodeURIComponent(props.relationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseChildCategoryRelation.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseChildCategoryRelation.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.param("relationId")(() => typia.assert(props.relationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
