import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrderItem } from "../../../../../structures/IShoppingMallOrderItem";
import { IPageIShoppingMallOrderItem } from "../../../../../structures/IPageIShoppingMallOrderItem";

/**
 * Add a new order item to a specific order.
 *
 * Create a new order item within a specified order. Authorized users
 * (guestUser, memberUser, sellerUser, adminUser) can add products associated
 * with specific snapshots to existing orders.
 *
 * Security considerations require user authentication and permission validation
 * to prevent unauthorized order modifications.
 *
 * This operation relates to the shopping_mall_order_items table, requiring
 * valid references to existing orders and product snapshots.
 *
 * Validation includes ensuring quantity and price are positive numbers and the
 * product snapshot exists.
 *
 * On success, returns the full detailed order item record.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order
 * @param props.body Details of the order item to create
 * @path /shoppingMall/adminUser/orders/:orderId/items
 * @accessor api.functional.shoppingMall.adminUser.orders.items.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target order */
    orderId: string & tags.Format<"uuid">;

    /** Details of the order item to create */
    body: IShoppingMallOrderItem.ICreate;
  };
  export type Body = IShoppingMallOrderItem.ICreate;
  export type Response = IShoppingMallOrderItem;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/adminUser/orders/:orderId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/adminUser/orders/${encodeURIComponent(props.orderId ?? "null")}/items`;
  export const random = (): IShoppingMallOrderItem =>
    typia.random<IShoppingMallOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List order items for a specified order.
 *
 * Retrieve a paginated list of order items within a specific order identified
 * by orderId.
 *
 * The list includes detailed information about each item such as quantity,
 * price, and status.
 *
 * Authorization roles supported are guestUser, memberUser, sellerUser, and
 * adminUser.
 *
 * Errors occur if orderId is invalid or unauthorized access is attempted.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order
 * @path /shoppingMall/adminUser/orders/:orderId/items
 * @accessor api.functional.shoppingMall.adminUser.orders.items.indexOrderItems
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexOrderItems(
  connection: IConnection,
  props: indexOrderItems.Props,
): Promise<indexOrderItems.Response> {
  return true === connection.simulate
    ? indexOrderItems.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexOrderItems.METADATA,
          path: indexOrderItems.path(props),
          status: null,
        },
      );
}
export namespace indexOrderItems {
  export type Props = {
    /** Unique identifier of the order */
    orderId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIShoppingMallOrderItem;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/adminUser/orders/:orderId/items",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/adminUser/orders/${encodeURIComponent(props.orderId ?? "null")}/items`;
  export const random = (): IPageIShoppingMallOrderItem =>
    typia.random<IPageIShoppingMallOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: indexOrderItems.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexOrderItems.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific order item information by orderId and orderItemId.
 *
 * Retrieve detailed information of a specific order item within an order. This
 * operation allows authorized users (guestUser, memberUser, sellerUser,
 * adminUser) to fetch data regarding a particular item ordered by the customer,
 * referencing the product snapshot at the time of order placement to ensure
 * consistency. The order item includes details such as quantity ordered and
 * unit price.
 *
 * Security: Only authorized roles can access order items.
 *
 * The operation relates to the shopping_mall_order_items database table, which
 * holds individual order line items referencing the shopping_mall_orders (via
 * orderId) and shopping_mall_sale_snapshots (product snapshot).
 *
 * Validation: Both 'orderId' and 'orderItemId' must be valid UUID strings
 * identifying existing records. If the item or order does not exist, a suitable
 * error response should be returned.
 *
 * Expected behavior: Returns a single shopping mall order item entity matching
 * the specified identifiers with full detail.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order
 * @param props.orderItemId Unique identifier of the target order item
 * @path /shoppingMall/adminUser/orders/:orderId/items/:orderItemId
 * @accessor api.functional.shoppingMall.adminUser.orders.items.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target order */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the target order item */
    orderItemId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallOrderItem;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/adminUser/orders/:orderId/items/:orderItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/adminUser/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.orderItemId ?? "null")}`;
  export const random = (): IShoppingMallOrderItem =>
    typia.random<IShoppingMallOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("orderItemId")(() => typia.assert(props.orderItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific order item within an order.
 *
 * Update an existing order item belonging to a specific order. Authorized users
 * (guestUser, memberUser, sellerUser, adminUser) can modify order item details
 * such as quantity, price, and status.
 *
 * Security measures ensure only authorized roles can perform updates.
 *
 * The shopping_mall_order_items table is the source of truth, with updates
 * validated against existing order and product snapshot references.
 *
 * Validation includes ensuring no negative values for quantities and valid
 * statuses.
 *
 * Returns the updated order item information.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order
 * @param props.orderItemId Unique identifier of the target order item
 * @param props.body Updated details of the order item
 * @path /shoppingMall/adminUser/orders/:orderId/items/:orderItemId
 * @accessor api.functional.shoppingMall.adminUser.orders.items.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target order */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the target order item */
    orderItemId: string & tags.Format<"uuid">;

    /** Updated details of the order item */
    body: IShoppingMallOrderItem.IUpdate;
  };
  export type Body = IShoppingMallOrderItem.IUpdate;
  export type Response = IShoppingMallOrderItem;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/adminUser/orders/:orderId/items/:orderItemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/adminUser/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.orderItemId ?? "null")}`;
  export const random = (): IShoppingMallOrderItem =>
    typia.random<IShoppingMallOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("orderItemId")(() => typia.assert(props.orderItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Erase a specific order item from an order.
 *
 * Delete a specific order item permanently from an order. This operation
 * removes the record completely from the database.
 *
 * Only authorized roles (guestUser, memberUser, sellerUser, adminUser) can
 * perform this action.
 *
 * The deletion affects the shopping_mall_order_items table as identified by the
 * parameters.
 *
 * No request body is required. On successful deletion, no response body is
 * returned.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order
 * @param props.orderItemId Unique identifier of the order item to delete
 * @path /shoppingMall/adminUser/orders/:orderId/items/:orderItemId
 * @accessor api.functional.shoppingMall.adminUser.orders.items.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target order */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the order item to delete */
    orderItemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/adminUser/orders/:orderId/items/:orderItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/adminUser/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.orderItemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("orderItemId")(() => typia.assert(props.orderItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
