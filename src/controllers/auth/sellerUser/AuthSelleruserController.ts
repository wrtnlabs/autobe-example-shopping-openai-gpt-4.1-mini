import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { post__auth_sellerUser_join } from "../../../providers/post__auth_sellerUser_join";
import { SelleruserAuth } from "../../../decorators/SelleruserAuth";
import { SelleruserPayload } from "../../../decorators/payload/SelleruserPayload";
import { post__auth_sellerUser_login } from "../../../providers/post__auth_sellerUser_login";
import { post__auth_sellerUser_refresh } from "../../../providers/post__auth_sellerUser_refresh";

import { IShoppingMallSellerUser } from "../../../api/structures/IShoppingMallSellerUser";

@Controller("/auth/sellerUser")
export class AuthSelleruserController {
  /**
   * Create a new seller user account and issue initial authorization tokens,
   * tied to shopping_mall_sellerusers table.
   *
   * This API endpoint allows new seller users (members with seller permissions)
   * to register by providing required credentials and profile data in
   * accordance with the shopping_mall_sellerusers Prisma schema.
   *
   * The operation performs validation of unique fields including email and
   * business_registration_number and securely hashes the provided password
   * before storage.
   *
   * Upon successful registration, the system issues JWT access and refresh
   * tokens embedding seller user identity and roles, conforming to the
   * IShoppingMallSellerUser.IAuthorized type.
   *
   * This operation is intended to be publicly accessible to enable new seller
   * onboarding while ensuring data integrity and security.
   *
   * Related operations include the login and token refresh endpoints for
   * authentication lifecycle management.
   *
   * @param connection
   * @param body Seller user registration request body adhering to
   *   IShoppingMallSellerUser.ICreate structure.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @SelleruserAuth()
    sellerUser: SelleruserPayload,
    @TypedBody()
    body: IShoppingMallSellerUser.ICreate,
  ): Promise<IShoppingMallSellerUser.IAuthorized> {
    try {
      return await post__auth_sellerUser_join({
        sellerUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate seller user credentials and issue JWT tokens, linked to
   * shopping_mall_sellerusers table.
   *
   * This API endpoint authenticates seller users by verifying their email and
   * password against the stored hashed password in the
   * shopping_mall_sellerusers table.
   *
   * Security best practices are applied including throttling, temporal locking
   * on failed attempts, and hash comparison to prevent timing attacks.
   *
   * Successful authentication issues JWT tokens with encoded claims for seller
   * user identification allowing subsequent authorized requests.
   *
   * This operation is related to registration and refresh token endpoints that
   * manage the full authentication lifecycle.
   *
   * @param connection
   * @param body Seller user login request body following
   *   IShoppingMallSellerUser.ILogin structure with email and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @SelleruserAuth()
    sellerUser: SelleruserPayload,
    @TypedBody()
    body: IShoppingMallSellerUser.ILogin,
  ): Promise<IShoppingMallSellerUser.IAuthorized> {
    try {
      return await post__auth_sellerUser_login({
        sellerUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT tokens for seller users with valid refresh token, linked to
   * shopping_mall_sellerusers table.
   *
   * This API endpoint enables seller users to renew their JWT access tokens by
   * providing a valid refresh token.
   *
   * It validates the token against issued records and expiration constraints in
   * the system tied to the shopping_mall_sellerusers role.
   *
   * Upon validation, new access and refresh tokens are generated and returned
   * within the IShoppingMallSellerUser.IAuthorized response format.
   *
   * This complements the join and login operations, forming a complete token
   * lifecycle management for seller users.
   *
   * @param connection
   * @param body Request containing valid refresh token for seller user,
   *   following IShoppingMallSellerUser.IRefresh structure.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @SelleruserAuth()
    sellerUser: SelleruserPayload,
    @TypedBody()
    body: IShoppingMallSellerUser.IRefresh,
  ): Promise<IShoppingMallSellerUser.IAuthorized> {
    try {
      return await post__auth_sellerUser_refresh({
        sellerUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
