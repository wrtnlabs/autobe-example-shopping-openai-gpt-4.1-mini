import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { post__shoppingMall_memberUser_favoriteInquiries } from "../../../../providers/post__shoppingMall_memberUser_favoriteInquiries";
import { MemberuserAuth } from "../../../../decorators/MemberuserAuth";
import { MemberuserPayload } from "../../../../decorators/payload/MemberuserPayload";
import { patch__shoppingMall_memberUser_favoriteInquiries } from "../../../../providers/patch__shoppingMall_memberUser_favoriteInquiries";
import { get__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId } from "../../../../providers/get__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId";
import { put__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId } from "../../../../providers/put__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId";
import { delete__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId } from "../../../../providers/delete__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId";

import { IShoppingMallFavoriteInquiry } from "../../../../api/structures/IShoppingMallFavoriteInquiry";
import { IPageIShoppingMallFavoriteInquiry } from "../../../../api/structures/IPageIShoppingMallFavoriteInquiry";

@Controller("/shoppingMall/memberUser/favoriteInquiries")
export class ShoppingmallMemberuserFavoriteinquiriesController {
  /**
   * Create a new favorite inquiry entry for a member user referencing an
   * inquiry snapshot. The favorite captures the inquiry state at the time of
   * favoriting, supporting personalized management and notification systems.
   *
   * Input validation ensures the member user and inquiry snapshot exist and are
   * valid UUIDs. The operation will fail if a favorite for the same inquiry
   * snapshot already exists for the member.
   *
   * The created favorite inquiry record includes timestamps for creation and
   * last update. This operation maps to the shopping_mall_favorite_inquiries
   * table directly.
   *
   * Authorization checks ensure only authenticated users can create favorites
   * on their behalf.
   *
   * @param connection
   * @param body Favorite inquiry creation data
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedBody()
    body: IShoppingMallFavoriteInquiry.ICreate,
  ): Promise<IShoppingMallFavoriteInquiry> {
    try {
      return await post__shoppingMall_memberUser_favoriteInquiries({
        memberUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve filtered, paginated list of favorite inquiries.
   *
   * Retrieve a filtered and paginated list of favorite inquiries.
   *
   * This operation allows authenticated users to search and manage their
   * inquiry favorites.
   *
   * The favorites reference inquiry snapshots preserving historical inquiry
   * states.
   *
   * The response contains a paginated collection of favorite inquiry summaries
   * suitable for user interface display.
   *
   * @param connection
   * @param body Search criteria and pagination parameters for favorite inquiry
   *   filtering
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async indexFavoriteInquiries(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedBody()
    body: IShoppingMallFavoriteInquiry.IRequest,
  ): Promise<IPageIShoppingMallFavoriteInquiry.ISummary> {
    try {
      return await patch__shoppingMall_memberUser_favoriteInquiries({
        memberUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific favorite inquiry by ID.
   *
   * Retrieve a detailed favorite inquiry record by its unique identifier. This
   * operation enables member users to view their saved favorite inquiries,
   * which are snapshots preserving the inquiry state at the time of
   * favoriting.
   *
   * Authorization is required to ensure the user can only access their own
   * favorites. The favorite inquiry entity links to a member user and holds a
   * reference to a snapshot of the inquiry for historical data integrity.
   *
   * The response includes creation and last updated timestamps to support
   * auditing and user interface display purposes. This operation reflects the
   * state from the shopping_mall_favorite_inquiries table.
   *
   * Clients should handle scenarios where the favorite inquiry does not exist
   * or access is forbidden according to business rules.
   *
   * @param connection
   * @param favoriteInquiryId Unique identifier of the target favorite inquiry
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":favoriteInquiryId")
  public async at(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedParam("favoriteInquiryId")
    favoriteInquiryId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallFavoriteInquiry> {
    try {
      return await get__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId(
        {
          memberUser,
          favoriteInquiryId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update favorite inquiry by ID.
   *
   * Update an existing favorite inquiry by ID. The update can modify the
   * inquiry snapshot reference and other editable properties.
   *
   * Security ensures only authorized users can update their favorites and
   * validation prevents duplicate favorites.
   *
   * The operation updates timestamps accordingly and ensures data integrity for
   * favorited inquiries.
   *
   * It operates on the shopping_mall_favorite_inquiries table and enforces
   * business rules on uniqueness and ownership.
   *
   * @param connection
   * @param favoriteInquiryId Unique identifier of the target favorite inquiry
   *   to update
   * @param body Favorite inquiry update data
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":favoriteInquiryId")
  public async update(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedParam("favoriteInquiryId")
    favoriteInquiryId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallFavoriteInquiry.IUpdate,
  ): Promise<IShoppingMallFavoriteInquiry> {
    try {
      return await put__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId(
        {
          memberUser,
          favoriteInquiryId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete favorite inquiry by ID.
   *
   * Delete (soft delete) a favorite inquiry by ID. Marks the record as deleted
   * without physical removal.
   *
   * Authorization enforces ownership restrictions.
   *
   * The operation affects the shopping_mall_favorite_inquiries table,
   * preserving data audit and history.
   *
   * Clients must handle scenarios where favorites are soft deleted and ensure
   * UI reflects state correctly.
   *
   * @param connection
   * @param favoriteInquiryId Unique identifier of the target favorite inquiry
   *   to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":favoriteInquiryId")
  public async erase(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedParam("favoriteInquiryId")
    favoriteInquiryId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await delete__shoppingMall_memberUser_favoriteInquiries_$favoriteInquiryId(
        {
          memberUser,
          favoriteInquiryId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
